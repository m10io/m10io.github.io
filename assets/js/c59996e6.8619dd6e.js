"use strict";(self.webpackChunkproduct=self.webpackChunkproduct||[]).push([[486],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>y});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(t),p=o,y=u["".concat(c,".").concat(p)]||u[p]||m[p]||i;return t?a.createElement(y,r(r({ref:n},d),{},{components:t})):a.createElement(y,r({ref:n},d))}));function y(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=p;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s[u]="string"==typeof e?e:o,r[1]=s;for(var l=2;l<i;l++)r[l]=t[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},5624:(e,n,t)=>{t.d(n,{Z:()=>c});var a=t(7294),o=t(5089),i=t(7316),r=t(5291),s=t(5308);function c(e){let n=e.code.trim();return a.createElement("div",{className:"code"},a.createElement("div",{className:"code-inner"},a.createElement(o.ZP,{value:n,height:e.height||"auto",theme:i.CP,extensions:[s.ih[e.lang]],readOnly:"true"}),a.createElement(r.Z,{code:n,className:"buttonGroup"})))}},1859:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>y,frontMatter:()=>s,metadata:()=>l,toc:()=>u});var a=t(7462),o=(t(7294),t(3905)),i=t(5624),r=t(5308);const s={},c="Actions",l={unversionedId:"api/actions",id:"api/actions",title:"Actions",description:"Transfers are great when we want to send money to an account, but what if we want to send a message? \u2014 Actions fill that gap.",source:"@site/docs/api/actions.mdx",sourceDirName:"api",slug:"/api/actions",permalink:"/api/actions",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Accounts",permalink:"/api/accounts"},next:{title:"Banks",permalink:"/api/banks"}},d={},u=[{value:"Requests",id:"requests",level:3},{value:"RPC",id:"rpc",level:3},{value:"Observations",id:"observations",level:3},{value:"Model",id:"model",level:2},{value:"API Calls",id:"api-calls",level:2},{value:"Invoke",id:"invoke",level:3},{value:"Get",id:"get",level:3},{value:"List",id:"list",level:3},{value:"Observe",id:"observe",level:3}],m={toc:u},p="wrapper";function y(e){let{components:n,...t}=e;return(0,o.kt)(p,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"actions"},"Actions"),(0,o.kt)("p",null,"Transfers are great when we want to send money to an account, but what if we want to send a message? \u2014 Actions fill that gap.\nActions look very similar to transfers, but they do not contain an amount. Instead, they contain a payload, an arbitrary blob of bytes.\nLet's look at a few use cases for actions that might further elucidate their usefulness."),(0,o.kt)("h3",{id:"requests"},"Requests"),(0,o.kt)("p",null,"The ledger already has support for sending money to another account, but how do you ask for money from an account?\nSay you run a yard-work business and need to invoice your client. Actions are M10's answer to this problem. We simply need to create an action\nwith the \"target\" set to the account you want to request money from. The payload will need to be in a well-known format.\nThis is such a common use case that we include such a format in our SDK. It's defined by the following protobuf."),(0,o.kt)(i.Z,{code:"\nmessage PaymentRequest {\n  m10.sdk.transaction.CreateTransfer transfer = 1;\n  enum PaymentRequestStatus {\n    PENDING = 0;\n    DECLINED = 1;\n    CANCELED = 2;\n    IN_PROGRESS = 3;\n  }\n  PaymentRequestStatus status = 2;\n}\n",lang:"protobuf",mdxType:"Highlight"}),(0,o.kt)("p",null,'You\'ll notice there is a "status" enum included in the above model. That is so the requester - and requestee - can keep track of the current status of the request.'),(0,o.kt)("h3",{id:"rpc"},"RPC"),(0,o.kt)("p",null,"Another common use case for actions is as a sort of on-ledger remote-procedure call. Imagine that an FX provider is running on the ledger,\nkind of you want to get a quote for an FX swap between two currencies. You could simply send an action to that provider's account with a quote request message. The FX provider would then send a response back that you could observe."),(0,o.kt)("h3",{id:"observations"},"Observations"),(0,o.kt)("p",null,"Observations are one of the key building blocks of the ledger. They are a way to receive a stream of events relating to a certain type. Actions are most useful when observed in real-time. Take for example the FX provider talked about above. Observations allow the FX provider to be notified when it receives an action. "),(0,o.kt)("p",null,"When combined with observations, actions become close to a distributed queue (like Kafka). Observations allow you to specify a starting txn id to observe from. You will then receive a stream of all the actions to occur since that txn-id. This allows you to have at-least-once semantics for messages delivered on the ledger! All without an external service."),(0,o.kt)("h2",{id:"model"},"Model"),(0,o.kt)(i.Z,{code:"\n// Invokes a registered action by sending an opaque payload to a Target\nmessage InvokeAction {\n  // Unique name of the action to invoke\n  string name = 1;\n  // Invoking account ID\n  bytes from_account = 3;\n  // Specifies the identity/identities who have permission to see & be notified\n  // of the invoked action\n  Target target = 4;\n  // Opaque payload\n  bytes payload = 5;\n}\n\nmessage Target {\n  oneof target {\n    // Account ID\n    bytes account_id = 1;\n    // Any Account\n    google.protobuf.Empty any_account = 2;\n  }\n}\n\nmessage Action {\n  uint64 tx_id = 1;\n  // Unique name of the action to invoke\n  string name = 2;\n  // [optional] unique Context ID, allowing linking of multiple requests\n  bytes context_id = 3;\n  // Invoking account ID\n  bytes from_account = 4;\n  // Specifies the identity/identities who have permission to see & be notified\n  // of the invoked action\n  Target target = 5;\n  // Opaque payload\n  bytes payload = 6;\n}\n",lang:"protobuf",mdxType:"Highlight"}),(0,o.kt)("h2",{id:"api-calls"},"API Calls"),(0,o.kt)("h3",{id:"invoke"},"Invoke"),(0,o.kt)("p",null,"Actions are identified using the ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," parameter. When ",(0,o.kt)("inlineCode",{parentName:"p"},"invoked")," they can be sent to a specific account using ",(0,o.kt)("inlineCode",{parentName:"p"},"Target::Account")," or broadcast to all using ",(0,o.kt)("inlineCode",{parentName:"p"},"Target::AnyAccount"),"."),(0,o.kt)(r.ZP,{code:{rust:'\nuse m10_sdk::ActionBuilder;\n\nlet my_data = "some data".to_owned().into_bytes();\n\n// Send to a specific account\nlet action_tx_id =client.action(\n      ActionBuilder::for_account("my.action", account_id![0, 2]?, account_id![0,1]?)\n        .payload(my_data.clone())\n  ).await?;\n\n// Broadcast to all\nlet action_tx_id = client.action(\n      ActionBuilder::for_all("my.action", account_id![0,1]?)\n        .payload(my_data.clone())\n  ).await?;\n',ts:'\nawait ledgerClient.action(sdk.ActionBuilder\n  .forAccount(\n    "my.action",\n    new sdk.AccountId("07800002000000000600000000000003"),\n    new sdk.AccountId("07800002000000000000000000000002")\n  )\n  .payload(new TextEncoder().encode("my_data"))\n);\nconst txId = await ledgerClient.action(sdk.ActionBuilder\n  .forAll(\n    "my.action",\n    new sdk.AccountId("07800002000000000600000000000003"),\n  )\n  .payload(new TextEncoder().encode("my_data"))\n);\n',dart:'\nimport \'package:m10_sdk/security/local_signing.dart\';\nimport \'package:m10_sdk/m10_sdk.dart\';\n\nfinal client = M10Sdk(\n  signer: await LocalSigning.loadKeyPair(\'test/keys/test_bank_admin.pkcs8\'),\n  ledgers: [ Ledger(operator: "m10.usd", url: "https://fis.m10.net") ],\n  disableTls: false,\n);\n// Send to a specific account\nawait client.invokeAction(\n  operator: "m10.usd",\n  name: "my.name",\n  fromAccountId: "07800002000000000600000000000003",\n  targetAccountId: "07800002000000000000000000000002",\n  payload: my_data\n);\n\n// Broadcast to all\nawait client.invokeAction(\n  operator: "m10.usd",\n  name: "my.name",\n  targetAll: true,\n  payload: my_data\n);\n',cli:"\n# Send to a specific account\nm10 call action \\\n    --name 'my.action' \\\n    --from 07800002000000000600000000000003\n    --payload \"my_data\" \\\n    --to 07800002000000000000000000000002\n\n# Broadcast to all\nm10 call action \\\n    --name 'my.action' \\\n    --from 07800002000000000600000000000003\n    --payload \"my_data\" \\\n    --broadcast\n"},mdxType:"Code"}),(0,o.kt)("h3",{id:"get"},"Get"),(0,o.kt)(r.ZP,{code:{rust:"\nlet action = client.get_action(action_tx_id).await?;\n",ts:"\nconst action = await ledgerClient.getAction(txId);\nconsole.log(action);\n",cli:"\nm10 get action 1234\n"},mdxType:"Code"}),(0,o.kt)("h3",{id:"list"},"List"),(0,o.kt)("p",null,"Actions can be filtered based on a specific account ID involved, e.g. the ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"target")," parameters, or based on a context ID."),(0,o.kt)(r.ZP,{code:{rust:'\nuse m10_sdk::{ActionsFilter, TxnFilter};\n\n// Filter by account ID\nlet actions = client.list_actions(\n        TxnFilter::<ActionsFilter>::by_account(\n            "my.action".to_owned(),\n            "07800002000000000600000000000003".parse()?,\n        )\n        .limit(10)\n    ).await?;\n\n// Filter by context ID\nlet actions = client.list_actions(\n        TxnFilter::<ActionsFilter>::by_context_id(\n            "my.action".to_owned(),\n            "my.context".as_bytes().to_vec(),\n        )\n        .limit(10)\n        .min_tx(10_000)\n        .max_tx(20_000),\n    ).await?;\n',ts:'\nconst actions = await ledgerClient.listActions(sdk.ActionsFilter.byAccount(\n  "my.action", new sdk.AccountId("07800002000000000600000000000003")));\nconsole.log(actions);\n',dart:'\nimport \'package:m10_sdk/security/local_signing.dart\';\nimport \'package:m10_sdk/m10_sdk.dart\';\n\nfinal client = M10Sdk(\n  signer: await LocalSigning.loadKeyPair(\'test/keys/test_bank_admin.pkcs8\'),\n  ledgers: [ Ledger(operator: "m10.usd", url: "https://fis.m10.net") ],\n  disableTls: false,\n);\n\n// Filter by account ID\nfinal actions = await client.listActions(\n    operator: "m10.usd",\n    name: "my.action",\n    accountId: "07800002000000000600000000000003",\n    limit: 10,\n    minTxId: 10000,\n    maxTxId: 20000);\n\n// Filter by context ID\nfinal actions = await client.listActions(\n    operator: "m10.usd",\n    name: "my.action",\n    contextId: "my.context".codeUnits,\n    limit: 10,\n    minTxId: 10000,\n    maxTxId: 20000);\n',cli:"\n# Filter by account ID\nm10 find action \\\n  --name 'my.action' \\\n  --account 07800002000000000600000000000003 \\\n  --limit 10 \\\n  --min-tx-id 10000 \\\n  --max-tx-id 20000\n\n# Filter by context ID\n# Note: context ID is parsed as hex\nm10 --context-id 6D792E636F6E74657874 find action \\\n  --name 'my.action' \\\n  --limit 10 \\\n  --min-tx-id 10000 \\\n  --max-tx-id 20000\n\n"},mdxType:"Code"}),(0,o.kt)("h3",{id:"observe"},"Observe"),(0,o.kt)("p",null,"Actions can be observed based on a list of specific account IDs involved, e.g. the ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"target")," parameters.\nIf any of the account IDs provided are matched, the relevant action will be observed."),(0,o.kt)("p",null,"It is recommended to use a separate client instance for streaming.\nName and involved accounts are required filter parameters to receive actions from subscriptions."),(0,o.kt)(r.ZP,{code:{rust:'\nuse m10_sdk::{AccountFilter};\nuse futures::stream::StreamExt;\n\nlet mut stream = client.observe_actions(\n  AccountFilter::name("my.action")\n    .involves("07800002000000000600000000000003".parse()?)\n    .involves("07800002000000000000000000000002".parse()?)\n    .starting_from(10_000),\n).await?;\n\nwhile let Some(msg) = stream.next().await{\n  match msg{\n    Ok(actions) => {\n      for action in actions{\n        println!("new action: {:#?}", action);\n      }\n    }\n    Err(err) => {\n      eprintln!("Error while receiving message: {}", err);\n      break;\n    }\n  };\n}\n',ts:'\nconst mybRootClient = new sdk.M10Client(LEDGER_URL, operatorSigner);\nconst [service, startObserver] = mybRootClient.observeActions(\n    new sdk.AccountFilter().involves(aliceAccountId).name("my.action"),\n);\nservice.on("data", (response: m10.sdk.IFinalizedTransactions) => {\n    console.log(response)\n});\nservice.on("error", (err: Error) => {\n  console.log(err)\n});\nstartObserver();\nawait mybRootClient.action(\n    sdk.ActionBuilder.forAccount("my.action", mybRootAccountId, aliceAccountId)\n);\nawait new Promise(f => setTimeout(f, 1000));\nservice.end(false);\n',dart:'\nimport \'package:m10_sdk/security/local_signing.dart\';\nimport \'package:m10_sdk/m10_sdk.dart\';\n\nfinal client = M10Sdk(\n  signer: await LocalSigning.loadKeyPair(\'test/keys/test_bank_admin.pkcs8\'),\n  ledgers: [ Ledger(operator: "m10.usd", url: "https://fis.m10.net") ],\n  disableTls: false,\n);\n\nfinal actions = await client.observeActions(\n    operator: "m10.usd",\n    name: "my.action",\n    accounts: [\n      "07800002000000000600000000000003",\n      "07800002000000000000000000000002",\n    ],\n    startingFrom: 10000);\n',cli:"\nm10 observe actions \\\n  --name 'my.action' \\\n  --ids 07800002000000000600000000000003 \\\n  --ids 07800002000000000000000000000002 \\\n  --starting-from 10000\n"},mdxType:"Code"}))}y.isMDXComponent=!0}}]);