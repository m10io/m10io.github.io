"use strict";(self.webpackChunkproduct=self.webpackChunkproduct||[]).push([[433,6505],{788:(e,n,t)=>{t.d(n,{A:()=>s});t(6540);var o=t(8186),a=t(7430),r=t(4612),c=t(4767),i=t(4848);function s(e){let n=e.code.trim();return(0,i.jsx)("div",{className:"code",children:(0,i.jsxs)("div",{className:"code-inner",children:[(0,i.jsx)(o.Ay,{value:n,height:e.height||"auto",theme:a.IR,extensions:[c.gq[e.lang]],readOnly:"true"}),(0,i.jsx)(r.A,{code:n,className:"buttonGroup"})]})})}},4753:(e,n,t)=>{t.r(n),t.d(n,{ProductName:()=>l,assets:()=>s,contentTitle:()=>i,default:()=>_,frontMatter:()=>c,metadata:()=>o,toc:()=>u});const o=JSON.parse('{"id":"components/variables","title":"variables","description":"","source":"@site/docs/components/variables.mdx","sourceDirName":"components","slug":"/components/variables","permalink":"/components/variables","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{}}');var a=t(4848),r=t(8453);const c={},i=void 0,s={},l=()=>(0,a.jsx)("span",{children:"DRM"}),u=[];function d(e){return(0,a.jsx)(a.Fragment,{})}function _(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d()}},7669:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>b,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"quickstart","title":"Quickstart","description":"This guide steps through how to use the  SDK & Command-Line Interface (CLI) to create a new digital currency called \\"My Bucks\\" with the currency code MYB.","source":"@site/docs/quickstart.mdx","sourceDirName":".","slug":"/quickstart","permalink":"/quickstart","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"sidebar","previous":{"title":"DRM Overview","permalink":"/overview"},"next":{"title":"API Overview","permalink":"/api/overview"}}');var a=t(4848),r=t(8453),c=t(4767),i=(t(788),t(4753));const s={sidebar_position:3},l="Quickstart",u={},d=[{value:"Before we start",id:"before-we-start",level:2},{value:"As the Central Bank",id:"as-the-central-bank",level:2},{value:"Create digital currency",id:"create-digital-currency",level:3},{value:"Create central bank key pair",id:"create-central-bank-key-pair",level:4},{value:"Output",id:"output",level:4},{value:"Create the root account",id:"create-the-root-account",level:4},{value:"Output",id:"output-1",level:4},{value:"Create the role and role-binding",id:"create-the-role-and-role-binding",level:4},{value:"Create issuance accounts for two banks",id:"create-issuance-accounts-for-two-banks",level:3},{value:"Bank One",id:"bank-one",level:4},{value:"Bank Two",id:"bank-two",level:4},{value:"Issue funds - Bank One",id:"issue-funds---bank-one",level:3},{value:"Transfer information",id:"transfer-information",level:4},{value:"Output",id:"output-2",level:4},{value:"Check the balance",id:"check-the-balance",level:3},{value:"Output",id:"output-3",level:4},{value:"As the Commercial Bank",id:"as-the-commercial-bank",level:2},{value:"Bank One - find my issuance account",id:"bank-one---find-my-issuance-account",level:3},{value:"Output",id:"output-4",level:4},{value:"Bank One - create Alice&#39;s customer account",id:"bank-one---create-alices-customer-account",level:3},{value:"Create role and role-binding for Bank One",id:"create-role-and-role-binding-for-bank-one",level:4},{value:"Create an account for Alice in Bank One",id:"create-an-account-for-alice-in-bank-one",level:4},{value:"Bank One - issue funds to Alice&#39;s customer account",id:"bank-one---issue-funds-to-alices-customer-account",level:3},{value:"Bank Two - create Bob&#39;s customer account",id:"bank-two---create-bobs-customer-account",level:3},{value:"Create roles and role-binding for Bank Two",id:"create-roles-and-role-binding-for-bank-two",level:4},{value:"Create account for Bob in Bank Two",id:"create-account-for-bob-in-bank-two",level:4},{value:"As Alice, send digital currency to Bob",id:"as-alice-send-digital-currency-to-bob",level:2},{value:"Check current balance",id:"check-current-balance",level:3},{value:"Output",id:"output-5",level:4},{value:"Transfer funds to Bob",id:"transfer-funds-to-bob",level:3},{value:"Look up recent transfers to confirm delivery",id:"look-up-recent-transfers-to-confirm-delivery",level:3},{value:"Output",id:"output-6",level:4},{value:"Check Alice&#39;s balance to confirm debit of funds",id:"check-alices-balance-to-confirm-debit-of-funds",level:3},{value:"Output",id:"output-7",level:4},{value:"As Bob, confirm receipt of funds",id:"as-bob-confirm-receipt-of-funds",level:2},{value:"Output",id:"output-8",level:4}];function _(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"quickstart",children:"Quickstart"})}),"\n",(0,a.jsxs)(n.p,{children:["This guide steps through how to use the ",(0,a.jsx)(i.ProductName,{}),' SDK & Command-Line Interface (CLI) to create a new digital currency called "My Bucks" with the currency code ',(0,a.jsx)(n.code,{children:"MYB"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["To better understand how the ",(0,a.jsx)(i.ProductName,{})," Platform serves as an API for the interaction between all network members you'll step through the entire process:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["As the Central Bank","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Create digital currency"}),"\n",(0,a.jsx)(n.li,{children:"Create two bank issuance accounts"}),"\n",(0,a.jsx)(n.li,{children:"Issue funds"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["As the Commercial Bank","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"As Bank One, create Alice's account and inssue funds"}),"\n",(0,a.jsx)(n.li,{children:"As Bank Two, create Bob's account"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:"As Alice, send digital currency to Bob"}),"\n",(0,a.jsx)(n.li,{children:"As Bob, confirm receipt of funds"}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["Before getting started, you'll need a root issuance account issued to you by ",(0,a.jsx)(i.ProductName,{})," and the associated private key. You'll also need the latest SDK version from ",(0,a.jsx)(n.a,{href:"https://github.com/m10io/sdk",children:"Github"}),". The REPL provided throughout this guide already has these provided for your easy exploration."]})}),"\n",(0,a.jsx)(n.h2,{id:"before-we-start",children:"Before we start"}),"\n",(0,a.jsx)(n.p,{children:"Depending on which SDK or terminal interface you're using, modify the following required code to match your environment:"}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\nexport LEDGER_ADDR='<hostname>'\nexport OPERATOR_KEY_FILE='file_location'\n",ts:'\nimport { M10Client, CryptoSigner } from "m10-sdk";\n\nconst LEDGER_URL = "https://app.m10.net";\nconst operatorClient = new M10Client(LEDGER_URL);\n\n// The preceding code defines a basic client that enables you to query public account details, transactions, and documents. \n// Keep in mind that accessing certain data might necessitate specific permissions.\n// Within the M10 ecosystem, an "Account" represents an entry on the M10 ledger and is associated with an "Ed25519" public key.\n// To begin querying data or sending transactions, you need to define a "CryptoSigner". This is a utility helper that works with "Ed25519" cryptography and the "pkcs8" PEM format.\n\nconst OPERATOR_KEY = "MFMCAQEwBQYDK2VwBCIEIMA9e6xaIFATarh2S5yVEe7jene/36EOcM+3B/sOH0y/oSMDIQDA9/WOLKaVoXq92lOSjloExzLXCdRz8oW9TweVGAGqZg==";\nconst operatorSigner = await CryptoSigner.fromPkcs8Pem(OPERATOR_KEY);\n\nconst operatorClient = new M10Client(LEDGER_URL, operatorSigner);\n',rust:'\nuse m10_sdk::client::Channel;\nuse m10_sdk::{Ed25519, M10Client};\nuse std::time::Duration;\n\nlet ledger_addr = "...";\nlet operator_key_file = "...";\nlet operator_channel = Channel::from_shared(ledger_addr).unwrap()\n  .keep_alive_while_idle(true)\n  .http2_keep_alive_interval(Duration::from_secs(30))\n  .timeout(Duration::from_secs(30))\n  .connect_lazy()\n  .unwrap();\nlet operator_signer = Ed25519::load_key_pair(operator_key_file).unwrap();\nlet operator_client = M10Client::new(operator_signer, operator_channel);\n'}}),"\n",(0,a.jsx)(n.h2,{id:"as-the-central-bank",children:"As the Central Bank"}),"\n",(0,a.jsx)(n.p,{children:"You start as the central bank to create and issue a new digital currency. Then you onboard commercial banks and create accounts for them before finally issuing money to them."}),"\n","\n","\n",(0,a.jsx)("img",{src:"/img/getting-started-cb-accounts.svg",style:{display:"block",margin:"auto",width:"90%"}}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(n.h3,{id:"create-digital-currency",children:"Create digital currency"}),"\n",(0,a.jsx)(n.h4,{id:"create-central-bank-key-pair",children:"Create central bank key pair"}),"\n","\n",(0,a.jsxs)(n.p,{children:["You need your central bank key pair in the ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/PKCS_8",children:"PKCS8"})," format. To generate a new key-pair, enter the following command:"]}),"\n",(0,a.jsx)(c.Ay,{code:{cli:'\nexport CB_KEY_FILE="central-bank.pkcs8"\nexport CB_PUBLIC_KEY=$(m10 create key-pair -a ed25519 --path $CB_KEY_FILE)\nm10 get public-key -k $CB_KEY_FILE\n',ts:'\nconst centralBankSigner = await CryptoSigner.generateKeyPair()\nconsole.log("public key is: ", centralBankSigner.getPublicKey().toString());\n',rust:'\nuse m10_sdk::Signer;\nuse base64::engine::Engine;\nuse base64::engine::general_purpose::STANDARD as BASE64;\n\nlet (central_bank_kp, central_bank_signer) = Ed25519::new_key_pair_exportable().unwrap();\nprintln!("public key is: {}", BASE64.encode(central_bank_signer.public_key()));\nprintln!("key pair is: {}", BASE64.encode(central_bank_kp));\n'}}),"\n",(0,a.jsx)(n.h4,{id:"output",children:"Output"}),"\n",(0,a.jsx)(n.p,{children:"You should see something like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'created key pair file: "central-bank.pkcs8"\npublic key is:\n"hOJIkyqJ7/dUStWzcgj+afT1dBvJKczPvl5q70MpMaY="\n'})}),"\n",(0,a.jsx)(n.h4,{id:"create-the-root-account",children:"Create the root account"}),"\n",(0,a.jsx)(n.p,{children:"Create the root account for the new digital currency associated with the central bank public key:"}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\n# Create the central bank issuance account\nexport MYB_ROOT_ACCOUNT=$(\n  m10 --server $LEDGER_ADDR --key-file $OPERATOR_KEY_FILE create account \\\n      --owner $CB_PUBLIC_KEY \\\n      --issuance \\\n      --public-name 'MYB' \\\n      --name 'MYBUCKS ROOT' \\\n      --code MYB \\\n      --decimals 2\n)\n# Verify the issuance account\necho $MYB_ROOT_ACCOUNT\n",ts:'\nimport { Operation_InsertDocument } from "m10-sdk/protobufs/sdk/document";\nimport { AccountMetadata } from "m10-sdk/protobufs/sdk/model/model";\nimport { Role, Rule_Verb, RoleBinding } from "m10-sdk/protobufs/sdk/rbac";\nimport {\n  AccountId,\n  Collection,\n  ResourceId,\n  CryptoSigner,\n  DirectoryClient,\n  getBaseAccessToken,\n  M10Client,\n} from "m10-sdk";\n\n/* This will create account instance in ledger */\nconst [, mybRootAccountId] = await operatorClient.createAccount({\n  frozen: false,\n  issuance: true,\n  instrument: Instrument.create({\n      code: "MYB",\n      decimalPlaces: 2,\n      description: "MYBUCKS ROOT",\n  }),\n});\n\nconst name = "My awesome Bank";\n\n/* This will bind public key to newly created account */\nawait operatorClient.documents([\n  {\n      oneofKind: "insertDocument",\n      insertDocument: Operation_InsertDocument.create({\n          collection: Collection.AccountMetadata,\n          document: AccountMetadata.toBinary(\n              AccountMetadata.create({\n                  name: name,\n                  owner: centralBankSigner.getPublicKey().toUint8Array(),\n                  publicName: name,\n                  id: mybRootAccountId.bytes,\n              }),\n          ),\n      }),\n  },\n]);\n\nconsole.log("Created accounts resource: ", mybRootAccountId.hex);\n',rust:'\nuse m10_sdk::AccountBuilder;\n\nlet myb_root_account_response = operator_client.create_account(\n  AccountBuilder::new()\n      .issuance(true)\n      .frozen(false)\n      .instrument("MYB".to_string(), 2, Some("MYBUCKS ROOT"))\n).await.unwrap();\n\nlet myb_root_account_id = myb_root_account_response.1;\nprintln!("Created accounts resource: {:?}", myb_root_account_id.to_string());\n'}}),"\n",(0,a.jsx)(n.admonition,{title:"Root Account Limit Warning",type:"danger",children:(0,a.jsxs)(n.p,{children:["The system supports ",(0,a.jsx)(n.strong,{children:"a maximum of 256 root accounts"}),". Once you reach this limit, you cannot create additional root accounts.\nThis is a ",(0,a.jsx)(n.strong,{children:"hard limit"})," - make sure to plan account creation carefully to avoid hitting this ceiling unexpectedly."]})}),"\n",(0,a.jsx)(n.h4,{id:"output-1",children:"Output"}),"\n",(0,a.jsx)(n.p,{children:"You should see something like:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"1a000000000000000000000000000000\n"})}),"\n",(0,a.jsx)(n.h4,{id:"create-the-role-and-role-binding",children:"Create the role and role-binding"}),"\n",(0,a.jsx)(n.p,{children:"The central bank must be given permission to create issuance accounts for banks. We do that by creating a role with the appropriate permissions that is then associated with the central bank's public key."}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\n# Create the central bank role\nexport CB_ROLE_ID=$(\n  m10 --server $LEDGER_ADDR --key-file $OPERATOR_KEY_FILE create role \\\n      --name central-bank-admin \\\n      --rule 'rule -c account-metadata -v Create' \\\n      --rule \"rule -c accounts -v Create -v Transact -i $MYB_ROOT_ACCOUNT\" \\\n      --rule 'rule -c roles -v Create' \\\n      --rule 'rule -c role-bindings -v Create'\n)\n# Verify the role ID\necho $CB_ROLE_ID\n\n# Bind the role to the public key of the central bank\nm10 --server $LEDGER_ADDR --key-file $OPERATOR_KEY_FILE create role-binding \\\n  --id $CB_ROLE_ID \\\n  --name central-bank-admin \\\n  --role $CB_ROLE_ID \\\n  --subject $CB_PUBLIC_KEY\n",ts:'\n/* Define role and rules for account (permissions) */\nconst role = Role.create({\n  id: ResourceId.generate().bytes,\n  name: name + "-role",\n  rules: [\n      {\n          collection: Collection.AccountMetadata,\n          verbs: [Rule_Verb.CREATE],\n      },\n      {\n          collection: Collection.LedgerAccount,\n          verbs: [Rule_Verb.CREATE],\n          instanceKeys: [Value.create({ value: { oneofKind: "bytesValue", bytesValue: accountId.bytes } })],\n      },\n      {\n          collection: Collection.LedgerAccount,\n          verbs: [ Rule_Verb.TRANSACT ],\n      },\n      {\n          collection: Collection.Role,\n          verbs: [ Rule_Verb.CREATE ],\n      },\n      {\n          collection: Collection.RoleBinding,\n          verbs: [ Rule_Verb.CREATE ],\n      },\n  ],\n});\n\n/* send transaction to create document with account\'s permissions */\nawait operatorClient.documents([{\n  oneofKind: "insertDocument",\n  insertDocument: Operation_InsertDocument.create({\n      collection: Collection.Role,\n      document: Role.toBinary(role),\n  }),\n}]);\n\n/* bind those permissions to created account */\nconst roleBinding = RoleBinding.create({\n  id: ResourceId.generate().bytes,\n  name: name + "-role-binding",\n  isUniversal: false,\n  subjects: [centralBankSigner.getPublicKey().toUint8Array()],\n  expressions: [],\n  owner: centralBankSigner.getPublicKey().toUint8Array(),\n  role: role.id,\n});\n\n/* send transaction to create document with role binding */\nawait operatorClient.documents([{\n  oneofKind: "insertDocument",\n  insertDocument: Operation_InsertDocument.create({\n      collection: Collection.RoleBinding,\n      document: RoleBinding.toBinary(roleBinding),\n  }),\n}]);\n',rust:'\nuse uuid::Uuid;\nuse m10_sdk::prost::bytes::Bytes;\nuse m10_sdk::{DocumentBuilder, sdk, Collection};\n\nlet central_bank_role_id = Uuid::new_v4();\noperator_client\n  .documents(\n      DocumentBuilder::default()\n          .insert(sdk::AccountMetadata {\n              owner: central_bank_signer.public_key().to_vec(),\n              profile_image_url: String::new(),\n              name: "MYBUCKS ROOT".to_string(),\n              public_name: "MYB".to_string(),\n              id: myb_root_account_id.to_vec(),\n          })\n          .insert(sdk::Role {\n              id: Bytes::copy_from_slice(central_bank_role_id.as_bytes()),\n              owner: Bytes::copy_from_slice(central_bank_signer.public_key()),\n              name: "central-bank-admin".to_string(),\n              rules: vec![\n                  sdk::Rule {\n                      collection: Collection::AccountMetadata.to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n                  sdk::Rule {\n                      collection: "ledger-accounts".to_string(),\n                      instance_keys: vec![sdk::Value {\n                          value: Some(sdk::value::Value::BytesValue(\n                              Bytes::copy_from_slice(&myb_root_account_id.to_be_bytes()),\n                          )),\n                      }],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n                  sdk::Rule {\n                      collection: "ledger-accounts".to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Transact as i32],\n                  },\n                  sdk::Rule {\n                      collection: Collection::Roles.to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n                  sdk::Rule {\n                      collection: Collection::RoleBindings.to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n              ],\n          })\n          .insert(sdk::RoleBinding {\n              id: Bytes::copy_from_slice(central_bank_role_id.as_bytes()),\n              owner: Bytes::copy_from_slice(central_bank_signer.public_key()),\n              name: "central-bank-admin".to_string(),\n              role: Bytes::copy_from_slice(central_bank_role_id.as_bytes()),\n              subjects: vec![Bytes::copy_from_slice(central_bank_signer.public_key())],\n              expressions: vec![],\n              is_universal: false,\n          }),\n  ).await.unwrap();\n\nprintln!("Created roles resource: {:?}", central_bank_role_id);\nprintln!("Created role-bindings resource: {:?}", central_bank_role_id);\n'}}),"\n",(0,a.jsx)(n.h3,{id:"create-issuance-accounts-for-two-banks",children:"Create issuance accounts for two banks"}),"\n",(0,a.jsx)(n.p,{children:"The process for creating bank keys and issuance accounts is similar to the steps for the central bank. Using the public keys for Bank One and Bank Two, we create issuance accounts for their commercial use and grant them permissions via new roles and role bindings."}),"\n",(0,a.jsx)(n.h4,{id:"bank-one",children:"Bank One"}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\n# Create key pair for Bank One\nexport BANKONE_KEY_FILE=\"bank-one.pkcs8\"\nexport BANKONE_PUBLIC_KEY=$(m10 create key-pair -a ed25519 --path $BANKONE_KEY_FILE)\n\n# Verify the public key of Bank One\necho $BANKONE_PUBLIC_KEY\n\n# Create issuance account for Bank One\nexport BANKONE_ACCOUNT=$(\n  m10 --server $LEDGER_ADDR --key-file $CB_KEY_FILE create account \\\n      --owner $BANKONE_PUBLIC_KEY \\\n      --issuance \\\n      --public-name 'Bank One MYB Issuance Account' \\\n      --name 'Bank One MYB' \\\n      --parent-account $MYB_ROOT_ACCOUNT\n)\n# Verify issuance account for Bank One\necho $BANKONE_ACCOUNT\n\n# Create role for Bank One\nexport BANKONE_ROLE_ID=$(\n  m10 --server $LEDGER_ADDR --key-file $CB_KEY_FILE create role \\\n      --name bankone-admin \\\n      --rule 'rule -c account-metadata -v Create' \\\n      --rule \"rule -c ledger-accounts -v Create -v Transact -i $BANKONE_ACCOUNT\" \\\n      --rule 'rule -c roles -v Create' \\\n      --rule 'rule -c role-bindings -v Create'\n)\n# Verify role for Bank One\necho $BANKONE_ROLE_ID\n\n# Bind the role to the public key of Bank One\nm10 --server $LEDGER_ADDR --key-file $CB_KEY_FILE create role-binding \\\n  --id $BANKONE_ROLE_ID \\\n  --name 'bankone-admin' \\\n  --role $BANKONE_ROLE_ID \\\n  --subject $BANKONE_PUBLIC_KEY\n",ts:'\nconst centralBankClient = new M10Client(LEDGER_URL, centralBankSigner);\n\nconst bankOneSigner = await CryptoSigner.generateKeyPair();\nconsole.log("public key is: ",  bankOneSigner.getPublicKey().toString());\n\nconst [, bankOneAccountId] = await centralBankClient.createAccount({\n  parentId: mybRootAccountId.bytes,\n  frozen: false,\n  issuance: true,\n});\n\nconst name = \'Bank One MYB\';\n\nawait centralBankClient.documents([\n  {\n      oneofKind: "insertDocument",\n      insertDocument: Operation_InsertDocument.create({\n          collection: Collection.AccountMetadata,\n          document: AccountMetadata.toBinary(\n              AccountMetadata.create({\n                  name: name,\n                  owner: bankOneSigner.getPublicKey().toUint8Array(),\n                  publicName: \'\',\n                  id: bankOneAccountId.bytes,\n              }),\n          ),\n      }),\n  },\n]);\nconsole.log("Created accounts resource: ", bankOneAccountId.toString());\n\nconst bankOneAdminRole = Role.create({\n  id: ResourceId.generate().bytes,\n  name: name + "-role",\n  rules: [\n      {\n          collection: Collection.AccountMetadata,\n          verbs: [ Rule_Verb.CREATE ],\n      },\n      {\n          collection: Collection.LedgerAccount,\n          verbs: [ Rule_Verb.CREATE ],\n          instanceKeys: [Value.create({ value: { oneofKind: "bytesValue", bytesValue: bankOneAccountId.bytes } })],\n      },\n      {\n          collection: Collection.LedgerAccount,\n          verbs: [ Rule_Verb.TRANSACT ],\n      },\n      {\n          collection: Collection.Role,\n          verbs: [ Rule_Verb.CREATE ],\n      },\n      {\n          collection: Collection.RoleBinding,\n          verbs: [ Rule_Verb.CREATE ],\n      },\n  ]\n});\nawait centralBankClient.documents([{\n  oneofKind: "insertDocument",\n  insertDocument: Operation_InsertDocument.create({\n      collection: Collection.Role,\n      document: Role.toBinary(bankOneAdminRole),\n  }),\n}]);\nconsole.log("Created roles resource: ", bankOneAdminRole.id.toString());\n\nconst bankOneAdminRoleBinding = RoleBinding.create({\n  id: ResourceId.generate().bytes,\n  name: name + \'-role-binding\',\n  isUniversal: false,\n  subjects: [bankOneSigner.getPublicKey().toUint8Array()],\n  expressions: [],\n  owner: bankOneSigner.getPublicKey().toUint8Array(),\n  role: bankOneAdminRole.id,\n});\n\nawait centralBankClient.documents([{\n  oneofKind: "insertDocument",\n  insertDocument: Operation_InsertDocument.create({\n      collection: Collection.RoleBinding,\n      document: RoleBinding.toBinary(bankOneAdminRoleBinding),\n  }),\n}]);\nconsole.log("Created role-bindings resource: ", bankOneAdminRoleBinding.id.toString());\n',rust:'\nlet central_bank_channel = Channel::from_shared(ledger_addr).unwrap()\n  .keep_alive_while_idle(true)\n  .http2_keep_alive_interval(Duration::from_secs(30))\n  .timeout(Duration::from_secs(30))\n  .connect_lazy()\n  .unwrap();\nlet central_bank_client = M10Client::new(central_bank_signer, central_bank_channel);\n\nlet (bankone_kp, bankone_signer) = Ed25519::new_key_pair_exportable().unwrap();\nprintln!("public key is: {}", BASE64.encode(bankone_signer.public_key()));\nprintln!("key pair is: {}", BASE64.encode(bankone_kp.clone()));\n\nlet bankone_account_response = central_bank_client.create_account(\n  AccountBuilder::parent(myb_root_account_id)\n      .issuance(true)\n      .frozen(false)\n).await.unwrap();\nlet bankone_account_id = bankone_account_response.1;\nprintln!("Created accounts resource: {:?}", bankone_account_id.to_string());\n\nlet bankone_role_id = Uuid::new_v4();\ncentral_bank_client\n  .documents(\n      DocumentBuilder::default()\n          .insert(sdk::AccountMetadata {\n              owner: bankone_signer.public_key().to_vec(),\n              profile_image_url: String::new(),\n              name: "Bank One MYB".to_string(),\n              public_name: "Bank One MYB Issuance Account".to_string(),\n              id: bankone_account_id.to_vec(),\n          })\n          .insert(sdk::Role {\n              id: Bytes::copy_from_slice(bankone_role_id.as_bytes()),\n              owner: Bytes::copy_from_slice(bankone_signer.public_key()),\n              name: "bankone-admin".to_string(),\n              rules: vec![\n                  sdk::Rule {\n                      collection: Collection::AccountMetadata.to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n                  sdk::Rule {\n                      collection: "ledger-accounts".to_string(),\n                      instance_keys: vec![sdk::Value {\n                          value: Some(sdk::value::Value::BytesValue(\n                              Bytes::copy_from_slice(&bankone_account_id.to_be_bytes()),\n                          )),\n                      }],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n                  sdk::Rule {\n                      collection: "ledger-accounts".to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Transact as i32],\n                  },\n                  sdk::Rule {\n                      collection: Collection::Roles.to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n                  sdk::Rule {\n                      collection: Collection::RoleBindings.to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n              ],\n          })\n          .insert(sdk::RoleBinding {\n              id: Bytes::copy_from_slice(bankone_role_id.as_bytes()),\n              owner: Bytes::copy_from_slice(bankone_signer.public_key()),\n              name: "bankone-admin".to_string(),\n              role: Bytes::copy_from_slice(bankone_role_id.as_bytes()),\n              subjects: vec![Bytes::copy_from_slice(bankone_signer.public_key())],\n              expressions: vec![],\n              is_universal: false,\n          }),\n  )\n  .await\n  .unwrap();\nprintln!("Created roles resource: {:?}", bankone_role_id);\nprintln!("Created role-bindings resource: {:?}", bankone_role_id);\n'}}),"\n",(0,a.jsx)(n.h4,{id:"bank-two",children:"Bank Two"}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\n# Verify the public key of Bank Two\nexport BANKTWO_KEY_FILE=\"bank-two.pkcs8\"\nexport BANKTWO_PUBLIC_KEY=$(m10 create key-pair -a ed25519 --path $BANKTWO_KEY_FILE)\n\n# Verify the public key of Bank Two\necho $BANKTWO_PUBLIC_KEY\n\n# Create issuance account for Bank Two\nexport BANKTWO_ACCOUNT=$(\n  m10 --server $LEDGER_ADDR --key-file $CB_KEY_FILE create account \\\n      --owner $BANKTWO_PUBLIC_KEY \\\n      --issuance \\\n      --public-name 'Bank Two MYB Issuance Account' \\\n      --name 'Bank Two MYB' \\\n      --parent-account $MYB_ROOT_ACCOUNT\n)\n# Verify issuance account for Bank Two\necho $BANKTWO_ACCOUNT\n\n# Create role for Bank Two\nexport BANKTWO_ROLE_ID=$(\n  m10 --server $LEDGER_ADDR --key-file $CB_KEY_FILE create role \\\n      --name banktwo-admin \\\n      --rule 'rule -c accounts-metadata -v Create' \\\n      --rule \"rule -c ledger-accounts -v Create -v Transact -i $BANKTWO_ACCOUNT\" \\\n      --rule 'rule -c roles -v Create' \\\n      --rule 'rule -c role-bindings -v Create'\n)\n# Verify role for Bank Two\necho $BANKTWO_ROLE_ID\n\n# Bind the role to the public key of Bank Two\nm10 --server $LEDGER_ADDR --key-file $CB_KEY_FILE create role-binding \\\n  --id $BANKTWO_ROLE_ID \\\n  --name 'banktwo-admin' \\\n  --role $BANKTWO_ROLE_ID \\\n  --subject $BANKTWO_PUBLIC_KEY\n",ts:'\nconst centralBankClient = new M10Client(LEDGER_URL, centralBankSigner);\n\nconst bankTwoSigner = await CryptoSigner.generateKeyPair();\nconsole.log("public key is: ",  bankTwoSigner.getPublicKey().toString());\n\nconst [, bankTwoAccountId] = await centralBankClient.createAccount({\n  parentId: mybRootAccountId.bytes,\n  frozen: false,\n  issuance: true,\n});\n\nconst name = \'Bank Two MYB\';\n\nawait centralBankClient.documents([\n  {\n      oneofKind: "insertDocument",\n      insertDocument: Operation_InsertDocument.create({\n          collection: Collection.AccountMetadata,\n          document: AccountMetadata.toBinary(\n              AccountMetadata.create({\n                  name: name,\n                  owner: bankTwoSigner.getPublicKey().toUint8Array(),\n                  publicName: \'\',\n                  id: bankTwoAccountId.bytes,\n              }),\n          ),\n      }),\n  },\n]);\nconsole.log("Created accounts resource: ", bankTwoAccountId.toString());\n\nconst bankTwoAdminRole = Role.create({\n  id: ResourceId.generate().bytes,\n  name: name + "-role",\n  rules: [\n      {\n          collection: Collection.AccountMetadata,\n          verbs: [ Rule_Verb.CREATE ],\n      },\n      {\n          collection: Collection.LedgerAccount,\n          verbs: [ Rule_Verb.CREATE ],\n          instanceKeys: [Value.create({ value: { oneofKind: "bytesValue", bytesValue: bankTwoAccountId.bytes } })],\n      },\n      {\n          collection: Collection.LedgerAccount,\n          verbs: [ Rule_Verb.TRANSACT ],\n      },\n      {\n          collection: Collection.Role,\n          verbs: [ Rule_Verb.CREATE ],\n      },\n      {\n          collection: Collection.RoleBinding,\n          verbs: [ Rule_Verb.CREATE ],\n      },\n  ]\n});\nawait centralBankClient.documents([{\n  oneofKind: "insertDocument",\n  insertDocument: Operation_InsertDocument.create({\n      collection: Collection.Role,\n      document: Role.toBinary(bankTwoAdminRole),\n  }),\n}]);\nconsole.log("Created roles resource: ", bankTwoAdminRole.id.toString());\n\nconst bankTwoAdminRoleBinding = RoleBinding.create({\n  id: ResourceId.generate().bytes,\n  name: name + \'-role-binding\',\n  isUniversal: false,\n  subjects: [bankTwoSigner.getPublicKey().toUint8Array()],\n  expressions: [],\n  owner: bankTwoSigner.getPublicKey().toUint8Array(),\n  role: bankTwoAdminRole.id,\n});\n\nawait centralBankClient.documents([{\n  oneofKind: "insertDocument",\n  insertDocument: Operation_InsertDocument.create({\n      collection: Collection.RoleBinding,\n      document: RoleBinding.toBinary(bankTwoAdminRoleBinding),\n  }),\n}]);\nconsole.log("Created role-bindings resource: ", bankTwoAdminRoleBinding.id.toString());\n',rust:'\nlet (banktwo_kp, banktwo_signer) = Ed25519::new_key_pair_exportable().unwrap();\nprintln!("public key is: {}", BASE64.encode(banktwo_signer.public_key()));\nprintln!("key pair is: {}", BASE64.encode(banktwo_kp.clone()));\n\nlet banktwo_account_response = central_bank_client.create_account(\n  AccountBuilder::parent(myb_root_account_id)\n      .issuance(true)\n      .frozen(false)\n).await.unwrap();\nlet banktwo_account_id = banktwo_account_response.1;\nprintln!("Created accounts resource: {:?}", banktwo_account_id.to_string());\n\nlet banktwo_role_id = Uuid::new_v4();\ncentral_bank_client\n  .documents(\n      DocumentBuilder::default()\n          .insert(sdk::AccountMetadata {\n              owner: banktwo_signer.public_key().to_vec(),\n              profile_image_url: String::new(),\n              name: "Bank Two MYB".to_string(),\n              public_name: "Bank Two MYB Issuance Account".to_string(),\n              id: banktwo_account_id.to_vec(),\n          })\n          .insert(sdk::Role {\n              id: Bytes::copy_from_slice(banktwo_role_id.as_bytes()),\n              owner: Bytes::copy_from_slice(banktwo_signer.public_key()),\n              name: "banktwo-admin".to_string(),\n              rules: vec![\n                  sdk::Rule {\n                      collection: Collection::AccountMetadata.to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n                  sdk::Rule {\n                      collection: "ledger-accounts".to_string(),\n                      instance_keys: vec![sdk::Value {\n                          value: Some(sdk::value::Value::BytesValue(\n                              Bytes::copy_from_slice(&banktwo_account_id.to_be_bytes()),\n                          )),\n                      }],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n                  sdk::Rule {\n                      collection: "ledger-accounts".to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Transact as i32],\n                  },\n                  sdk::Rule {\n                      collection: Collection::Roles.to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n                  sdk::Rule {\n                      collection: Collection::RoleBindings.to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n              ],\n          })\n          .insert(sdk::RoleBinding {\n              id: Bytes::copy_from_slice(banktwo_role_id.as_bytes()),\n              owner: Bytes::copy_from_slice(banktwo_signer.public_key()),\n              name: "banktwo-admin".to_string(),\n              role: Bytes::copy_from_slice(banktwo_role_id.as_bytes()),\n              subjects: vec![Bytes::copy_from_slice(banktwo_signer.public_key())],\n              expressions: vec![],\n              is_universal: false,\n          }),\n  )\n  .await\n  .unwrap();\nprintln!("Created roles resource: {:?}", banktwo_role_id);\nprintln!("Created role-bindings resource: {:?}", banktwo_role_id);\n'}}),"\n",(0,a.jsx)(n.h3,{id:"issue-funds---bank-one",children:"Issue funds - Bank One"}),"\n",(0,a.jsx)(n.p,{children:"To issue funds to Bank One from the central bank, we create a transfer from the root account to Bank One's account:"}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\n# Create transfer\nexport FUNDS_TRANSFER_ID=$(\n  m10 --server $LEDGER_ADDR --key-file $CB_KEY_FILE create transfer \\\n      --from-account $MYB_ROOT_ACCOUNT \\\n      --to-account $BANKONE_ACCOUNT \\\n      --amount 100000 \\\n      --memo Funding\n)\n# Verify transaction ID\necho $FUNDS_TRANSFER_ID\n",ts:'\nconst mybRootBankInfo = await centralBankClient.getAccountInfo(mybRootAccountId);\n\nconst transferTxId = await centralBankClient.transfer([\n  {\n      fromAccountId: mybRootAccountId.bytes,\n      toAccountId: bankOneAccountId.bytes,\n      amount: 100_000 * 10 ** mybRootBankInfo.decimalPlaces,\n      metadata: [convertMemoToAny({ plaintext: "Funds" })],\n  },\n]);\n\nconsole.log("created transfer: ", transferTxId.toString());\n',rust:'\nuse m10_sdk::{TransferBuilder, StepBuilder};\n\nlet bankone_channel = Channel::from_shared(ledger_addr).unwrap()\n  .keep_alive_while_idle(true)\n  .http2_keep_alive_interval(Duration::from_secs(30))\n  .timeout(Duration::from_secs(30))\n  .connect_lazy()\n  .unwrap();\nlet bankone_client = M10Client::new(bankone_signer, bankone_channel);\nlet issue_funds_to_bankone = TransferBuilder::new()\n  .step(\n      StepBuilder::new(myb_root_account_id, bankone_account_id, 100_000)\n          .metadata(sdk::Memo { plaintext: "Funds".to_string() })\n  );\nlet issue_funds_to_bankone_tx_id = bankone_client.transfer(issue_funds_to_bankone).await.unwrap();\nprintln!("created transfer: {:?}", issue_funds_to_bankone_tx_id);\n'}}),"\n",(0,a.jsx)(n.h4,{id:"transfer-information",children:"Transfer information"}),"\n",(0,a.jsxs)(n.p,{children:["We retrieve information about the transfer by using the transaction ID (",(0,a.jsx)(n.code,{children:"tx_id"}),") from the output:"]}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\nm10 --server $LEDGER_ADDR --key-file $BANKONE_KEY_FILE get transfer $FUNDS_TRANSFER_ID\n",ts:"\nconst issueFundsToBankOneGetTransfer = await centralBankClient.getTransfer(transferTxId);\nconsole.log(issueFundsToBankOneGetTransfer);\n",rust:'\nlet issue_funds_to_bankone_info = bankone_client.get_transfer(issue_funds_to_bankone_tx_id).await.unwrap();\nprintln!("{:#?}", issue_funds_to_bankone_info);\n'}}),"\n",(0,a.jsx)(n.h4,{id:"output-2",children:"Output"}),"\n",(0,a.jsx)(n.p,{children:"You should see something like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'(\n    tx_id: 129630000,\n    context_id: [],\n    timestamp: "2023-08-25 10:39:55.210130",\n    steps: [\n        (\n            from: "0c000000000000000000000000000000",\n            to: "0c800000000000000000000000000002",\n            amount: 100000,\n            metadata: [\n                Memo((plaintext:"Funds")),\n            ],\n        ),\n    ],\n    success: true,\n    state: Accepted,\n)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"check-the-balance",children:"Check the balance"}),"\n",(0,a.jsxs)(n.p,{children:["In the Central Bank root account, after the transfer, notice the change in the ",(0,a.jsx)(n.code,{children:"issuance.balance"})," field:"]}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\nm10 --server $LEDGER_ADDR --key-file $CB_KEY_FILE get account $MYB_ROOT_ACCOUNT\n",ts:"\nconst getMybRootAccount = await centralBankClient.getAccount(mybRootAccountId);\nconsole.log(getMybRootAccount);\n",rust:'\nlet get_myb_account_info = central_bank_client.get_account(myb_root_account_id).await.unwrap();\nprintln!("{:#?}", get_myb_account_info);\n'}}),"\n",(0,a.jsx)(n.h4,{id:"output-3",children:"Output"}),"\n",(0,a.jsx)(n.p,{children:"You should see something like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'(\n    id: 0c000000000000000000000000000000,\n    balance: 0,\n    frozen: false,\n    code: "MYB",\n    decimals: 2,\n    balance_limit: 18446744073709551615,\n    issuance: Some((\n        balance: 100000,\n        issuance_accounts: 2,\n        holding_accounts: 0,\n    )),\n)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"as-the-commercial-bank",children:"As the Commercial Bank"}),"\n",(0,a.jsx)(n.p,{children:"After a bank has been onboarded, the bank can use the API to create and manage accounts for their customers.\nHere we will use the API as two different commercial banks titled:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:'"Bank One"'}),"\n",(0,a.jsx)(n.li,{children:'"Bank Two"'}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Each of these banks have a new customer that we will create accounts for, and deposit funds to."}),"\n","\n","\n",(0,a.jsx)("img",{src:"/img/getting-started-bank-accounts.svg",style:{display:"block",margin:"auto",width:"90%"}}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(n.h3,{id:"bank-one---find-my-issuance-account",children:"Bank One - find my issuance account"}),"\n",(0,a.jsx)(n.p,{children:"Let's use the SDK to find Bank One's issuance account that was just created by the Central Bank. We can list all accounts by owner. Since we only created one account in this tutorial, we will get one account returned, which is Bank One's issuance account."}),"\n",(0,a.jsxs)(n.p,{children:["The following code creates a new ",(0,a.jsx)(n.code,{children:"ListAccountsRequest"})," filtering by our ",(0,a.jsx)(n.code,{children:"public_key"})," as the owner. It then signs the request using our private key and submits the request to the ledger."]}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\nm10 --server $LEDGER_ADDR --key-file $BANKONE_KEY_FILE find accounts --owner $BANKONE_PUBLIC_KEY\n",ts:'\nconst bankOneClient = new M10Client(LEDGER_URL, bankOneSigner)\n\nconst findBankOneIssuanceAccount = await bankOneClient.listAccountMetadata({\n  filter: {\n      oneofKind: "owner",\n      owner: bankOneSigner.getPublicKey().toUint8Array(),\n  },\n});\nconsole.log(findBankOneIssuanceAccount);\n',rust:'\nuse m10_sdk::LedgerClient;\nlet bankone_ledger_client_signer = Ed25519::from_pkcs8(bankone_kp.as_slice()).unwrap();\nlet bankone_ledger_client_channel = Channel::from_shared(ledger_addr).unwrap()\n  .keep_alive_while_idle(true)\n  .http2_keep_alive_interval(Duration::from_secs(30))\n  .timeout(Duration::from_secs(30))\n  .connect_lazy()\n  .unwrap();\nlet mut bankone_ledger_client = LedgerClient::new(bankone_ledger_client_channel);\nlet find_bankone_account_request = sdk::ListAccountMetadataRequest {\n  filter: Some(sdk::list_account_metadata_request::Filter::Owner(bankone_ledger_client_signer.public_key().to_vec())),\n  page: None,\n};\nlet find_bankone_account_request_signed = bankone_ledger_client_signer.sign_request(\n  find_bankone_account_request\n).await.unwrap();\nlet find_bankone_account = bankone_ledger_client.list_account_metadata(find_bankone_account_request_signed).await.unwrap();\nprintln!("{:#?}", find_bankone_account);\n'}}),"\n",(0,a.jsx)(n.h4,{id:"output-4",children:"Output"}),"\n",(0,a.jsx)(n.p,{children:"You should see something like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'[\n    (\n        id: "0c800000000000000000000000000002",\n        owner: "i+VZtoZhwLhfMZ2Etv23029ulURf1yz4Gb6RaqSGS9Y=",\n        name: "Bank One MYB",\n        public_name: "Bank One MYB Issuance Account",\n        profile_image_url: "",\n    ),\n]\n'})}),"\n",(0,a.jsx)(n.h3,{id:"bank-one---create-alices-customer-account",children:"Bank One - create Alice's customer account"}),"\n",(0,a.jsxs)(n.p,{children:["Now we will create a new child account for a customer named ",(0,a.jsx)(n.em,{children:"Alice"})," under Bank One's issuance account. Alice needs her own key pair to sign transactions with, so first we generate her key (normally, Alice would generate her key pair herself in a client app):"]}),"\n",(0,a.jsx)(c.Ay,{code:{cli:'\n# Create key pair for Alice\nexport ALICE_KEY_FILE="alice.pkcs8"\nexport ALICE_PUBLIC_KEY=$(m10 create key-pair -a ed25519 --path $ALICE_KEY_FILE)\n\n# Verify the public key of Alice\nm10 get public-key $ALICE_KEY_FILE\n',ts:'\n// Let\'s assume Alice has created her own key pair at client app and sent it to us, for instance, via POST request\nawait bankOneClient.documents([\n  {\n      oneofKind: "insertDocument",\n      insertDocument: Operation_InsertDocument.create({\n          collection: Collection.AccountSet,\n          document: AccountMetadata.toBinary(\n              AccountMetadata.create({\n                  owner: aliceSigner.getPublicKey().toUint8Array(),\n                  id: aliceId.toUint8Array(),\n              }),\n          ),\n      }),\n  },\n]);\nconsole.log("public key is: ", aliceSigner.getPublicKey().toString());\nconsole.log("Created account-sets resource: ", aliceId.toString());\n',rust:'\nlet (alice_kp, alice_signer) = Ed25519::new_key_pair_exportable().unwrap();\nprintln!("public key is: {}", BASE64.encode(alice_signer.public_key()));\nprintln!("key pair is: {}", BASE64.encode(alice_kp.clone()));\nlet alice_account_response = bankone_client.create_account(\n  AccountBuilder::parent(bankone_account_id)\n      .issuance(false)\n      .frozen(false)\n).await.unwrap();\nlet alice_account_id = alice_account_response.1;\nprintln!("Created accounts resource: {:?}", alice_account_id.to_string());\n'}}),"\n",(0,a.jsx)(n.h4,{id:"create-role-and-role-binding-for-bank-one",children:"Create role and role-binding for Bank One"}),"\n",(0,a.jsxs)(n.p,{children:["Bank One doesn't yet have any roles that we can use to assign permissions. Therefore, we create a ",(0,a.jsx)(n.code,{children:"customer"})," role and a role-binding where we use Alice as a subject:"]}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\n# Create the 'customer' role\nexport BANKONE_CUSTOMER_ROLE_ID=$(\n  m10 --server $LEDGER_ADDR --key-file $BANKONE_KEY_FILE create role \\\n      --name customer \\\n      --rule 'rule -c account-metadata -v Create' \\\n      --rule 'rule -c ledger-accounts -v Create'\n)\n\n# Verify 'customer' role\necho $BANKONE_CUSTOMER_ROLE_ID\n\n# Bind the 'customer' role to the public key of Alice\nm10 --server $LEDGER_ADDR --key-file $BANKONE_KEY_FILE create role-binding \\\n  --id $BANKONE_CUSTOMER_ROLE_ID \\\n  --name customer \\\n  --role $BANKONE_CUSTOMER_ROLE_ID \\\n  --subject $ALICE_PUBLIC_KEY\n\n# Verify the role binding\nm10 --server $LEDGER_ADDR --key-file $BANKONE_KEY_FILE list role-binding --name customer\n",ts:'\n// Assume we have Alice\'s public key from the request\nconst alicePublicKeyBytes = getAlicePublicKeyFromRequest();\n\nconst name = \'alice-the-customer\';\n\nconst bankOneCustomerRole = Role.create({\n  id: ResourceId.generate().bytes,\n  name: name + "-role",\n  rules: [\n      {\n          collection: Collection.AccountMetadata,\n          verbs: [Rule_Verb.CREATE],\n      },\n      {\n          collection: Collection.LedgerAccount,\n          verbs: [Rule_Verb.CREATE],\n      },\n  ],\n});\nawait bankOneClient.documents([{\n  oneofKind: "insertDocument",\n  insertDocument: Operation_InsertDocument.create({\n      collection: Collection.Role,\n      document: Role.toBinary(bankOneCustomerRole),\n  }),\n}]);\nconsole.log("Created roles resource: ", bankOneCustomerRole.id.toString());\n\nconst bankOneCustomerRoleBinding = RoleBinding.create({\n  id: ResourceId.generate().bytes,\n  name: name + \'-role-binding\',\n  isUniversal: false,\n  subjects: [aliceSigner.getPublicKey().toUint8Array()],\n  expressions: [],\n  // HERE: we set bankOne as the owner of the role-binding, to prevent any other includes Alice from modify it\n  owner: bankOneSigner.getPublicKey().toUint8Array(),\n  role: bankOneCustomerRole.id,\n});\nawait operatorClient.documents([{\n  oneofKind: "insertDocument",\n  insertDocument: Operation_InsertDocument.create({\n      collection: Collection.RoleBinding,\n      document: RoleBinding.toBinary(bankOneCustomerRoleBinding),\n  }),\n}]);\nconsole.log("Created role-bindings resource: ", bankOneCustomerRoleBinding.id.toString());\n',rust:'\nlet bankone_customer_role_id = Uuid::new_v4();\nbankone_client\n  .documents(\n      DocumentBuilder::default()\n          .insert(sdk::AccountMetadata {\n              owner: alice_signer.public_key().to_vec(),\n              profile_image_url: String::new(),\n              name: "Alice".to_string(),\n              public_name: "Alice Account".to_string(),\n              id: alice_account_id.to_vec(),\n          })\n          .insert(sdk::Role {\n              id: Bytes::copy_from_slice(bankone_customer_role_id.as_bytes()),\n              owner: Bytes::copy_from_slice(bankone_client.signer().public_key()),\n              name: "customer".to_string(),\n              rules: vec![\n                  sdk::Rule {\n                      collection: Collection::AccountMetadata.to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n                  sdk::Rule {\n                      collection: "ledger-accounts".to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n              ],\n          })\n          .insert(sdk::RoleBinding {\n              id: Bytes::copy_from_slice(bankone_customer_role_id.as_bytes()),\n              owner: Bytes::copy_from_slice(bankone_client.signer().public_key()),\n              name: "customer".to_string(),\n              role: Bytes::copy_from_slice(bankone_customer_role_id.as_bytes()),\n              subjects: vec![Bytes::copy_from_slice(alice_signer.public_key())],\n              expressions: vec![],\n              is_universal: false,\n          }),\n  ).await.unwrap();\nprintln!("Created roles resource: {:?}", bankone_customer_role_id);\nprintln!("Created role-bindings resource: {:?}", bankone_customer_role_id);\n'}}),"\n",(0,a.jsx)(n.h4,{id:"create-an-account-for-alice-in-bank-one",children:"Create an account for Alice in Bank One"}),"\n",(0,a.jsxs)(n.p,{children:["Now we can create an ",(0,a.jsx)(n.code,{children:"account"})," for Alice:"]}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\n# Create Alice's account\nexport ALICE_ACCOUNT=$(\n  m10 --server $LEDGER_ADDR --key-file $ALICE_KEY_FILE create account \\\n      --owner $ALICE_PUBLIC_KEY \\\n      --public-name 'Alice Account' \\\n      --name 'Alice' \\\n      --parent-account $BANKONE_ACCOUNT\n)\n# Verify Alice's account\necho $ALICE_ACCOUNT\n",ts:'\nconst aliceClient = new M10Client(LEDGER_URL, aliceSigner);\nconst [,aliceAccountId] = await aliceClient.createAccount({\n  parentId: bankOneAccountId.bytes,\n});\nconst aliceAccountMetadataName = \'Alice\';\n\nawait centralBankClient.documents([\n  {\n      oneofKind: "insertDocument",\n      insertDocument: Operation_InsertDocument.create({\n          collection: Collection.AccountMetadata,\n          document: AccountMetadata.toBinary(\n              AccountMetadata.create({\n                  id: aliceAccountId.bytes,\n                  name: aliceAccountMetadataName,\n                  owner: aliceSigner.getPublicKey().toUint8Array(),\n                  publicName: aliceAccountMetadataName,\n              }),\n          ),\n      }),\n  },\n]);\nconsole.log("Created accounts resource: ", aliceAccountId.toString());\n',rust:"\n// Created as a part of the previous step\n"}}),"\n",(0,a.jsx)(n.h3,{id:"bank-one---issue-funds-to-alices-customer-account",children:"Bank One - issue funds to Alice's customer account"}),"\n",(0,a.jsx)(n.p,{children:"Alice's new account has a balance of zero, so we will issue funds from her bank (Bank One) to Alice's new account:"}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\nm10 --server $LEDGER_ADDR --key-file $BANKONE_KEY_FILE create transfer \\\n  --from-account $BANKONE_ACCOUNT \\\n  --to-account $ALICE_ACCOUNT \\\n  --amount 1000 \\\n  --memo Funds\n",ts:'\nconst transferTxId = await bankOneClient.transfer([\n  {\n      fromAccountId: bankOneAccountId.bytes,\n      toAccountId: aliceAccountId.bytes,\n      amount: 1_000 * 10 ** mybRootBankInfo.decimalPlaces,\n      metadata: [convertMemoToAny({ plaintext: "Funds" })],\n  },\n]);\nconsole.log("created transfer: ", transferTxId);\n',rust:'\nlet issue_funds_to_alice = TransferBuilder::new()\n  .step(\n      StepBuilder::new(bankone_account_id, alice_account_id, 1000)\n          .metadata(sdk::Memo { plaintext: "Funds".to_string() })\n  );\nlet issue_funds_to_alice_tx_id = bankone_client.transfer(issue_funds_to_alice).await.unwrap();\nprintln!("created transfer: {:?}", issue_funds_to_alice_tx_id);\n'}}),"\n",(0,a.jsx)(n.h3,{id:"bank-two---create-bobs-customer-account",children:"Bank Two - create Bob's customer account"}),"\n",(0,a.jsx)(n.p,{children:"To setup Bob as a customer of Bank Two, we go through the same process as for Alice at Bank One:"}),"\n",(0,a.jsx)(c.Ay,{code:{cli:'\n# Create key pair for Bob\nexport BOB_KEY_FILE="bob.pkcs8"\nexport BOB_PUBLIC_KEY=$(m10 create key-pair -a ed25519 --path $BOB_KEY_FILE)\n\n# Verify the public key of Bob\nm10 get public-key $BOB_KEY_FILE\n',ts:"\n// This step remains the same as for Alice to create AccountSet, but with bankTwo\n",rust:'\nlet banktwo_channel = Channel::from_shared(ledger_addr).unwrap()\n  .keep_alive_while_idle(true)\n  .http2_keep_alive_interval(Duration::from_secs(30))\n  .timeout(Duration::from_secs(30))\n  .connect_lazy()\n  .unwrap();\nlet banktwo_client = M10Client::new(banktwo_signer, banktwo_channel);\nlet (bob_kp, bob_signer) = Ed25519::new_key_pair_exportable().unwrap();\nprintln!("public key is: {}", BASE64.encode(bob_signer.public_key()));\nprintln!("key pair is: {}", BASE64.encode(bob_kp));\nlet bob_account_response = banktwo_client.create_account(\n  AccountBuilder::parent(banktwo_account_id)\n      .issuance(false)\n      .frozen(false)\n).await.unwrap();\nlet bob_account_id = bob_account_response.1;\nprintln!("Created accounts resource: {:?}", bob_account_id.to_string());\n'}}),"\n",(0,a.jsx)(n.h4,{id:"create-roles-and-role-binding-for-bank-two",children:"Create roles and role-binding for Bank Two"}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\n# Create the 'customer' role\nexport BANKTWO_CUSTOMER_ROLE_ID=$(\n  m10 --server $LEDGER_ADDR --key-file $BANKTWO_KEY_FILE create role \\\n      --name customer \\\n      --rule 'rule -c accounts -v Create' \\\n      --rule 'rule -c ledger-accounts -v Create'\n)\n# Verify 'customer' role\necho $BANKTWO_CUSTOMER_ROLE_ID\n\n# Bind the 'customer' role to the public key of Bob\nm10 --server $LEDGER_ADDR --key-file $BANKTWO_KEY_FILE create role-binding \\\n  --id $BANKTWO_CUSTOMER_ROLE_ID \\\n  --name customer \\\n  --role $BANKTWO_CUSTOMER_ROLE_ID \\\n  --subjects $BOB_PUBLIC_KEY\n\n# Verify the role binding\nm10 --server $LEDGER_ADDR --key-file $BANKTWO_KEY_FILE list role-binding --name customer\n",ts:"\n// This step remains the same as for Alice to create Roles and Role Bindings, but with bankTwo\n",rust:'\nlet banktwo_customer_role_id = Uuid::new_v4();\nbanktwo_client\n  .documents(\n      DocumentBuilder::default()\n          .insert(sdk::AccountMetadata {\n              owner: bob_signer.public_key().to_vec(),\n              profile_image_url: String::new(),\n              name: "Bob".to_string(),\n              public_name: "Bob Account".to_string(),\n              id: bob_account_id.to_vec(),\n          })\n          .insert(sdk::Role {\n              id: Bytes::copy_from_slice(banktwo_customer_role_id.as_bytes()),\n              owner: Bytes::copy_from_slice(banktwo_client.signer().public_key()),\n              name: "customer".to_string(),\n              rules: vec![\n                  sdk::Rule {\n                      collection: Collection::AccountMetadata.to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n                  sdk::Rule {\n                      collection: "ledger-accounts".to_string(),\n                      instance_keys: vec![],\n                      verbs: vec![sdk::rule::Verb::Create as i32],\n                  },\n              ],\n          })\n          .insert(sdk::RoleBinding {\n              id: Bytes::copy_from_slice(banktwo_customer_role_id.as_bytes()),\n              owner: Bytes::copy_from_slice(banktwo_client.signer().public_key()),\n              name: "customer".to_string(),\n              role: Bytes::copy_from_slice(banktwo_customer_role_id.as_bytes()),\n              subjects: vec![Bytes::copy_from_slice(bob_signer.public_key())],\n              expressions: vec![],\n              is_universal: false,\n          }),\n  )\n  .await\n  .unwrap();\nprintln!("Created roles resource: {:?}", banktwo_customer_role_id);\nprintln!("Created role-bindings resource: {:?}", banktwo_customer_role_id);\n'}}),"\n",(0,a.jsx)(n.h4,{id:"create-account-for-bob-in-bank-two",children:"Create account for Bob in Bank Two"}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\n# Create Bob's account\nexport BOB_ACCOUNT=$(\n  m10 --server $LEDGER_ADDR --key-file $BOB_KEY_FILE create account \\\n      --owner $BOB_PUBLIC_KEY \\\n      --public-name 'Bob Account' \\\n      --name 'Bob' \\\n      --parent-account $BANKTWO_ACCOUNT\n)\n# Verify Bob's account\necho $BOB_ACCOUNT\n",ts:"\n// This step remains the same as for Alice to create AccountMetadata, but with bankTwo\n",rust:"\n// Created as a part of the previous step\n"}}),"\n",(0,a.jsx)(n.h2,{id:"as-alice-send-digital-currency-to-bob",children:"As Alice, send digital currency to Bob"}),"\n",(0,a.jsx)(n.p,{children:'Now that Alice and Bob have accounts on the ledger and appropriate permissions, they can use the API (or one of the SDKs or the CLI) to send and receive "My Bucks" to each other.'}),"\n",(0,a.jsx)(n.p,{children:"The hierarchical ledger tree of accounts enables a double-entry accounting system, creating atomic transactions that all participants in the activity can observe and respond to."}),"\n",(0,a.jsx)("img",{src:"/img/getting-started-send-transfer.svg",style:{display:"block",margin:"auto",width:"90%"}}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(n.h3,{id:"check-current-balance",children:"Check current balance"}),"\n",(0,a.jsx)(n.p,{children:"First we check Alice's account balance (it should be 1000 MYB, since we previously issued that from Bank One into Alice's account):"}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\nm10 --server $LEDGER_ADDR --key-file $ALICE_KEY_FILE get account $ALICE_ACCOUNT\n",ts:"\nconst aliceLedgerAccountBeforeTransfer = await aliceClient.getAccount(aliceAccountId);\nconsole.log(aliceLedgerAccountBeforeTransfer);\n",rust:'\nlet alice_channel = Channel::from_shared(ledger_addr).unwrap()\n  .keep_alive_while_idle(true)\n  .http2_keep_alive_interval(Duration::from_secs(30))\n  .timeout(Duration::from_secs(30))\n  .connect_lazy()\n  .unwrap();\nlet alice_client = M10Client::new(alice_signer, alice_channel);\nlet get_alice_account_info = alice_client.get_account(alice_account_id).await.unwrap();\nprintln!("{:#?}", get_alice_account_info);\n'}}),"\n",(0,a.jsx)(n.h4,{id:"output-5",children:"Output"}),"\n",(0,a.jsxs)(n.p,{children:["You should see something like the following, which includes ",(0,a.jsx)(n.code,{children:"balance: 100000"})," (the two last digits are the two decimals):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'(\n    id: "0c800000000000000000000000000003",\n    balance: 100000,\n    frozen: false,\n    code: "MYB",\n    decimals: 2,\n    balance_limit: 18446744073709551615,\n    issuance: None,\n)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"transfer-funds-to-bob",children:"Transfer funds to Bob"}),"\n",(0,a.jsx)(n.p,{children:"Since Alice has funds in her account, she can transfer 100 MYB to Bob:"}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\nm10 --server $LEDGER_ADDR --key-file $ALICE_KEY_FILE create transfer \\\n  --from-account $ALICE_ACCOUNT \\\n  --to-account $BOB_ACCOUNT \\\n  --amount 10000 \\\n  --memo groceries\n",ts:'\nconst transferTxId = await bankOneClient.transfer([\n  {\n      fromAccountId: aliceAccountId.bytes,\n      toAccountId: bobAccountId.bytes,\n      amount: 100 * 10 ** mybRootBankInfo.decimalPlaces,\n      metadata: [convertMemoToAny({ plaintext: "groceries" })],\n  },\n]);\nconsole.log("created transfer: ", transferTxId);\n',rust:'\nlet transfer_funds_from_alice_to_bob = TransferBuilder::new()\n  .step(\n      StepBuilder::new(alice_account_id, bob_account_id, 100)\n          .metadata(sdk::Memo { plaintext: "groceries".to_string() })\n  );\nlet transfer_funds_from_alice_to_bob_tx_id = alice_client.transfer(\n  transfer_funds_from_alice_to_bob\n).await.unwrap();\nprintln!("created transfer: {:?}", transfer_funds_from_alice_to_bob_tx_id);\n'}}),"\n",(0,a.jsx)(n.h3,{id:"look-up-recent-transfers-to-confirm-delivery",children:"Look up recent transfers to confirm delivery"}),"\n",(0,a.jsxs)(n.p,{children:["The following code gets a list of transfers. We filter the output by ",(0,a.jsx)(n.code,{children:"account"}),"."]}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\nm10 --server $LEDGER_ADDR --key-file $ALICE_KEY_FILE find transfers --account $ALICE_ACCOUNT\n",ts:'\nconst listAliceTransfers = await testCaseInstances.accountClient.listTransfers({\n  filter: {\n      oneofKind: "accountId",\n      accountId: aliceAccountId.bytes,\n  },\n});\nconsole.log(listAliceTransfers);\n',rust:'\nuse m10_sdk::{TxnFilter, TransferFilter};\n\nlet list_alice_transfers = alice_client.list_transfers(\n  TxnFilter::<TransferFilter>::by_account(alice_account_id)\n).await.unwrap();\nprintln!("{:#?}", list_alice_transfers);\n'}}),"\n",(0,a.jsx)(n.p,{children:"There are other filter options as well:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Filter option"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"-m, --min-tx-id <MIN_TX_ID>"})}),(0,a.jsx)(n.td,{children:"Set minimum transaction ID [default: 0]"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"-x, --max-tx-id <MAX_TX_ID>"})}),(0,a.jsx)(n.td,{children:"Set maximum transaction ID"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"-a, --account <ACCOUNT>"})}),(0,a.jsx)(n.td,{children:"Set account filter"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"-c, --context-id <CONTEXT_ID>"})}),(0,a.jsx)(n.td,{children:"Set contextID filter"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"-l, --limit <LIMIT>"})}),(0,a.jsx)(n.td,{children:"Set limit of results [default: 20]"})]})]})]}),"\n",(0,a.jsxs)(n.p,{children:["For more filter details, see the ",(0,a.jsx)(n.a,{href:"https://docs.atelio.com/embedded/reference/post-transfer",children:"Create transfer"})," endpoint."]}),"\n",(0,a.jsxs)(n.p,{children:["The purpose of the ",(0,a.jsx)(n.code,{children:"context_id"})," is to provide a unique identifier that links together multiple transactions that are part of a larger, multi-legged operation, particularly across different ledgers. This is crucial for scenarios like foreign exchange transfers where a single user action results in separate transactions on different ledgers (e.g., USD ledger and EUR ledger)."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"context_id"})," allows:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Tracking related transactions"})," - It provides a way to tie together the various legs of a multi-ledger transfer, enabling tracking of the entire operation\u2019s status and progress. This is important for users to be able to see the complete picture of their transfer, even if parts of it are happening on different ledgers."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Simplified remote lookup and authorization"})," - It acts as a shared secret, enabling users involved in a multi-ledger transfer to look up the status of remote transactions without needing to have direct access or authorization to the remote ledger. This allows users to verify that all parts of their transfer have been completed successfully."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Resolution of ambiguity in transaction matching"})," - In cases where multiple similar transactions occur (e.g., multiple transfers of the same amount to the same account), the context_id helps disambiguate which transactions are related to a specific user\u2019s initial request."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["In essence, the ",(0,a.jsx)(n.code,{children:"context_id"})," provides the glue that holds together the different pieces of a complex, distributed transaction and enables a coherent view of the entire operation."]}),"\n",(0,a.jsx)(n.h4,{id:"output-6",children:"Output"}),"\n",(0,a.jsx)(n.p,{children:"The output of the above request returns the transfers made by Alice with the most recent transaction at the top:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'[\n    (\n        tx_id: 133930000,\n        context_id: [],\n        timestamp: "2023-08-25 10:42:42.786861",\n        steps: [\n            (\n                from: "0c800000000000000000000000000003",\n                to: "0c800001000000000000000000000003",\n                amount: 10000,\n                metadata: [Memo((plaintext:"groceries"))],\n            ),\n        ],\n        success: true,\n        state: Accepted,\n    ),\n    (\n        tx_id: 132160000,\n        context_id: [],\n        timestamp: "2023-08-25 10:41:53.310156",\n        steps: [\n            (\n                from: "0c800000000000000000000000000002",\n                to: "0c800000000000000000000000000003",\n                amount: 10000,\n                metadata: [Memo((plaintext:"Funds"))],\n            ),\n        ],\n        success: true,\n        state: Accepted,\n    ),\n]\n'})}),"\n",(0,a.jsx)(n.h3,{id:"check-alices-balance-to-confirm-debit-of-funds",children:"Check Alice's balance to confirm debit of funds"}),"\n",(0,a.jsx)(n.p,{children:"You can make sure there was a debit of Alice's funds, and you can check that with the following code:"}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\nm10 --server $LEDGER_ADDR --key-file $ALICE_KEY_FILE get account $ALICE_ACCOUNT\n",ts:"\nconst aliceLedgerAccountAfterTransfer = await aliceClient.getAccount(aliceAccountId);\nconsole.log(aliceLedgerAccountAfterTransfer);\n",rust:'\nlet get_alice_account_info = alice_client.get_account(alice_account_id).await.unwrap();\nprintln!("{:#?}", get_alice_account_info);\n'}}),"\n",(0,a.jsx)(n.h4,{id:"output-7",children:"Output"}),"\n",(0,a.jsxs)(n.p,{children:["You should see something like the following where the ",(0,a.jsx)(n.code,{children:"balance"})," field is less than before:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'(\n    id: "0c800000000000000000000000000003",\n    balance: 90000,\n    frozen: false,\n    code: "MYB",\n    decimals: 2,\n    balance_limit: 18446744073709551615,\n    issuance: None,\n)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"as-bob-confirm-receipt-of-funds",children:"As Bob, confirm receipt of funds"}),"\n",(0,a.jsx)(n.p,{children:"The following code checks Bob's balance to confirm credit of Alice's funds:"}),"\n",(0,a.jsx)(c.Ay,{code:{cli:"\nm10 --server $LEDGER_ADDR --key-file $BOB_KEY_FILE get account $BOB_ACCOUNT\n",ts:"\nconst bobLedgerAccountAfterTransfer = await bobClient.getAccount(bobAccountId);\nconsole.log(bobLedgerAccountAfterTransfer);\n",rust:'\nlet bob_channel = Channel::from_shared(ledger_addr).unwrap()\n  .keep_alive_while_idle(true)\n  .http2_keep_alive_interval(Duration::from_secs(30))\n  .timeout(Duration::from_secs(30))\n  .connect_lazy()\n  .unwrap();\nlet bob_client = M10Client::new(bob_signer, bob_channel);\nlet get_bob_account_info = bob_client.get_account(bob_account_id).await.unwrap();\nprintln!("{:#?}", get_bob_account_info);\n'}}),"\n",(0,a.jsx)(n.h4,{id:"output-8",children:"Output"}),"\n",(0,a.jsxs)(n.p,{children:["You should see something like the following with ",(0,a.jsx)(n.code,{children:"balance: 10000"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'(\n    id: "0c800001000000000000000000000003",\n    balance: 10000,\n    frozen: false,\n    code: "MYB",\n    decimals: 2,\n    balance_limit: 18446744073709551615,\n    issuance: None,\n)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Now that you've taken the first steps in exploring the fundamental functions of the ",(0,a.jsx)(i.ProductName,{})," platform, it's time to venture further and try the following:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Request transaction and account information using the different keys you've created."}),"\n",(0,a.jsx)(n.li,{children:"Consider which personas can see which activities."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["A key area of mastery that will enhance your understanding and utilization of the ",(0,a.jsx)(i.ProductName,{})," platform is understanding how RBAC and the ledger hierarchy influence access and how they model the compliance requirements in financial services."]})]})}function b(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(_,{...e})}):_(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>i});var o=t(6540);const a={},r=o.createContext(a);function c(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);